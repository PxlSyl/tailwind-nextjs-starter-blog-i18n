---
title: PrÃ©sentation du Starter Blog Tailwind Next-js V 2.0
series:
  order: 3
  title: "Blog Starter"
date: '2023-08-05'
lastmod: '2023-08-05'
language: fr
localeid: 'releasev2'
tags: ['next-js', 'tailwind', 'guide', 'fonctionnalites']
authors: ['tailsazimuth']
images: ['/static/images/twitter-card.png']
draft: false
summary: PrÃ©sentation du modÃ¨le Starter Blog Tailwind Next-js v2.0, refactorisÃ© avec le rÃ©pertoire Nextjs App et la configuration des composants React Server. DÃ©couvrez les nouvelles fonctionnalitÃ©s et comment migrer Ã  partir de la V1.
---

## Introduction

Bienvenue dans le nouveau modÃ¨le de Starter Blog Tailwind Nextjs v2.0. Cette version est une refactorisation majeure de la base de code pour prendre en charge le rÃ©pertoire Nextjs App et les composants React Server. Lisez la suite pour dÃ©couvrir les nouvelles fonctionnalitÃ©s et comment migrer depuis la V1.

<TOCInline toc={props.toc} exclude="Introduction" />

## De la V1 Ã  la V2

![Github Traffic](/static/images/github-traffic.png)

Le modÃ¨le a Ã©tÃ© publiÃ© pour la premiÃ¨re fois en janvier 2021 et a depuis Ã©tÃ© utilisÃ© par des milliers d'utilisateurs. Il a Ã©tÃ© prÃ©sentÃ© sur [ModÃ¨les Next.js](https://vercel.com/templates/next.js/tailwind-css-starter-blog), [Tailwind Awesome](https://www.tailwindawesome.com/resources /tailwind-nextjs-starter-blog) parmi d'autres sites de rÃ©fÃ©rencement. Il attire chaque jour plus de 200 visiteurs uniques, avec entre 1 500 et 2 000 pages vues, avec 13 000 forks et de nombreux autres clones.

Un grand merci Ã  la communautÃ© d'utilisateurs et de contributeurs pour avoir fait de ce modÃ¨le un succÃ¨s ! J'ai crÃ©Ã© un petit montage vidÃ©o des blogs (tout en nettoyant la liste dans le readme) pour mettre en valeur la diversitÃ© des blogs crÃ©Ã©s grÃ¢ce au modÃ¨le et cÃ©lÃ©brer cette Ã©tape importante:

<video controls>
  <source
    src="https://github-production-user-asset-6210df.s3.amazonaws.com/28362229/258559849-2124c81f-b99d-4431-839c-347e01a2616c.webm"
    type="video/webm"
  />
</video>

La version 2 s'appuie sur le succÃ¨s de la version prÃ©cÃ©dente et introduit de nombreuses nouvelles fonctionnalitÃ©s et amÃ©liorations. La base de code a Ã©tÃ© refactorisÃ©e pour prendre en charge l'app router de Next.js et les composants React server. Markdown / MDX est dÃ©sormais traitÃ© Ã  l'aide de Contentlayer, un SDK de contenu "typesafe" grÃ¢ce Ã  typescript, qui valide et transforme votre contenu en donnÃ©es JSON de type sÃ©curisÃ©. Il s'intÃ¨gre Ã  Pliny, une nouvelle bibliothÃ¨que qui fournit des composants Next.js prÃªts Ã  l'emploi pour amÃ©liorer votre site statique avec des analyses, des commentaires et un abonnement Ã  la newsletter. Un nouveau composant de recherche avec palette de commandes (âŒ˜-k) a Ã©galement Ã©tÃ© ajoutÃ© au modÃ¨le.

Plongeons dans les nouvelles fonctionnalitÃ©s et amÃ©liorations de la V2.

## RÃ©pertoire d'application Next.js et composants Server React

Maintenant que l'[app router de Next.js](https://nextjs.org/docs/app) est enfin stable et est principalement compatible avec Page Router, la base de code a Ã©tÃ© migrÃ©e vers une nouvelle configuration. Cela permet une approche de rendu hybride, avec l'utilisation de composants React Server gÃ©nÃ©rÃ©s cÃ´tÃ© serveur pour des chargements de pages plus rapides et des tailles de bundle plus petites, tout en conservant la possibilitÃ© d'intÃ©grer les composants React cÃ´tÃ© client pour l'interactivitÃ©.[^1]

Avec des possibilitÃ©s supplÃ©mentaires survient un [nouveau paradigme](https://nextjs.org/docs/getting-started/react-essentials) et son lot d'apprentissage. J'ai migrÃ© la base de code pour utiliser au maximum les nouvelles fonctionnalitÃ©s. Cela inclut des modifications dans la structure des dossiers, la division des composants en composants serveur et clients, l'exploitation de la rÃ©cupÃ©ration de donnÃ©es cÃ´tÃ© serveur et l'utilisation des [mÃ©tadonnÃ©es] recommandÃ©es (https://nextjs.org/docs/app/building-your-application/optimizing/metadata ), API pour le SEO.

Bien que cela simplifie dans une certaine mesure la base de code, cela rend aussi la migration Ã  partir de l'ancienne base de code plus difficile. Si vous souhaitez migrer, je vous recommande de partir d'un nouveau modÃ¨le et de copier vos personnalisations et votre contenu existant. Consultez la section [recommandations de migration](#migration-recommendations) pour plus de dÃ©tails.

## Typescript First

La base de code a Ã©tÃ© migrÃ©e vers Typescript. Alors que la version prÃ©cÃ©dente du modÃ¨le Ã©tait disponible en Javascript et Typescript, j'ai dÃ©cidÃ© de rÃ©duire la charge de maintenance et de me concentrer sur Typescript. Cela permet Ã©galement une meilleure vÃ©rification de type et une meilleure complÃ©tion du code dans les IDE.

Typescript correspond Ã©galement parfaitement Ã  notre nouveau processeur remark sÃ©curisÃ© - Contentlayer.

## Contentlayer

[Contentlayer](https://www.contentlayer.dev/) est un SDK de contenu qui valide et transforme votre contenu en donnÃ©es JSON de type sÃ©curisÃ© que vous pouvez facilement importer dans votre application. Cela facilite le travail avec des fichiers markdown locaux ou MDX. Cela permets de remplacer Â«MDX-bundlerÂ» et notre propre workflow de traitement markdown.

Tout d'abord, une source de contenu est dÃ©finie, spÃ©cifiant le nom du type de document, la source oÃ¹ il se trouve ainsi que les champs de premier plan et tous les champs calculÃ©s supplÃ©mentaires qui doivent Ãªtre gÃ©nÃ©rÃ©s dans le cadre du processus.

```ts:contentlayer.config.ts
export const Blog = defineDocumentType(() => ({
  name: 'Blog',
  filePathPattern: 'blog/**/*.mdx',
  contentType: 'mdx',
  fields: {
    title: { type: 'string', required: true },
    date: { type: 'date', required: true },
    tags: { type: 'list', of: { type: 'string' }, default: [] },
    ...
  },
  computedFields: {
    readingTime: { type: 'json', resolve: (doc) => readingTime(doc.body.raw) },
    slug: {
      type: 'string',
      resolve: (doc) => doc._raw.flattenedPath.replace(/^.+?(\/)/, ''),
    }
    ...
  },
}))
```

Contentlayer traite ensuite les fichiers MDX avec les plugins de Remark ou de Rehype de markdown souhaitÃ©s, valide le schÃ©ma, gÃ©nÃ¨re des dÃ©finitions de type et gÃ©nÃ¨re des fichiers json qui peuvent Ãªtre facilement importÃ©s dans nos pages. Le rechargement Ã  chaud est prÃªt Ã  l'emploi, de sorte que les modifications apportÃ©es aux fichiers markdown seront immÃ©diatement reflÃ©tÃ©es dans le navigateur!

## Pliny

La popularitÃ© du modÃ¨le s'explique en grande partie par sa personnalisation et son intÃ©gration avec d'autres services, des fournisseurs d'analyse aux solutions de commentaires. Cependant, cela signifie qu'une grande partie du code passe-partout doit Ãªtre colocalisÃ© dans le modÃ¨le mÃªme si l'utilisateur n'utilise pas la fonctionnalitÃ©. Les mises Ã  jour et les corrections de bugs devaient Ãªtre copiÃ©es manuellement dans la base de code de l'utilisateur.

Pour rÃ©soudre ce problÃ¨me, j'ai rÃ©sumÃ© la logique dans un rÃ©pertoire sÃ©parÃ© - [Pline](https://github.com/timlrx/pliny). Pliny fournit des composants Next.js prÃªts Ã  l'emploi pour amÃ©liorer les sites statiquesÂ :

- Analytique
  - Google Analytics
  - Plausible Analytics
  - Simple Analytics
  - Umami Analytics
  - Posthog
- Commentaires
  - Disqus
  - Giscus
  - Utterances
- Newsletter (utilise l'API de routage de Next 13 )
  - Buttondown
  - Convertkit
  - Email Octopus
  - Klaviyo
  - Mailchimp
  - Revue
- Recherche de palette de commandes avec feuille de style tailwind
  - Algolia
  - Kbar (local search)
- Composants utilitaires de l'interface utilisateur
  - Bleed
  - Newsletter / Blog Newsletter
  - Pre / Code block
  - Table of Contents

Choisissez votre service prÃ©fÃ©rÃ© en modifiant Â« siteMetadata.js Â» et en changeant les champs appropriÃ©s. Par exemple pour passer d'Umami Analytics Ã  Plausible, on peut modifier les champs suivants :

```diff-js:siteMetadata.js
analytics: {
-   umamiAnalytics: {
-     // We use an env variable for this site to avoid other users cloning our analytics ID
-     umamiWebsiteId: process.env.NEXT_UMAMI_ID, // e.g. 123e4567-e89b-12d3-a456-426614174000
-   },
+    plausibleAnalytics: {
+      plausibleDataDomain: '', // e.g. tailwind-nextjs-starter-blog.vercel.app
+    },
},
```

Les modifications apportÃ©es au fichier de configuration sont automatiquement propagÃ©es aux composants. Aucune modification du modÃ¨le n'est requise.

Sous le capot, Pliny exporte des composants de haut niveau tels que `<Analytics AnalyticsConfig={analyticsConfig}/>` et `<Comments commentsConfig={commentsConfig}/>` qui intÃ¨grent un objet de configuration et restituent le composant appropriÃ©. Ã‰tant donnÃ© que les mises en page sont dÃ©finies cÃ´tÃ© serveur, Next.js est capable d'utiliser l'objet de configuration pour dÃ©terminer quel composant restituer et envoyer uniquement le paquet de composants requis au client.

## Nouveau composant de recherche

Qu'est-ce qu'un blog en 2023 sans barre de recherche avec palette de commandes?

L'une des fonctionnalitÃ©s les plus demandÃ©es a Ã©tÃ© ajoutÃ©e ğŸ‰! Le composant de recherche prend en charge 2 fournisseurs de recherche: Algolia et la recherche locale avec Kbar.

### Algolia

[Algolia Docsearch](https://docsearch.algolia.com/) est un service gratuit populaire utilisÃ© sur de nombreux sites Web de documentation. Il supprime automatiquement le site Web soumis Ã  l'indexation et rend le rÃ©sultat de la recherche disponible via une belle boÃ®te de dialogue modale. Le composant Pliny s'inspire grandement de l'implÃ©mentation de Docusaurus et est livrÃ© avec une feuille de style compatible avec le thÃ¨me CSS Tailwind.

### Kbar

[Kbar](https://github.com/timc1/kbar) est une interface cmd+k rapide, portable et extensible. L'implÃ©mentation de Pliny utilise kbar pour crÃ©er une boÃ®te de dialogue de recherche locale. Le composant charge un fichier JSON, Â« search.json Â» par dÃ©faut, qui a Ã©tÃ© crÃ©Ã© lors du processus de crÃ©ation de la couche de contenu. Essayez d'appuyer sur âŒ˜-k ou ctrl-k pour voir la barre de recherche en actionÂ !

## Mises Ã  jour du style et de la mise en page

### ThÃ¨me

`tailwind.config.js` a Ã©tÃ© mis Ã  jour pour utiliser les valeurs par dÃ©faut de la typographie tailwind lorsque cela est possible et pour utiliser la prise en charge intÃ©grÃ©e du mode sombre via la classe `prose-invert`. Cela remplace la classe et la configuration Â« prose-dark Â» prÃ©cÃ©dentes.

La couleur du thÃ¨me principal est mise Ã  jour de Â« teal Â» Ã  Â« pink Â» et le thÃ¨me gris principal de Â« neutral Â» Ã  Â« gray Â».

Inter est dÃ©sormais remplacÃ© par Space Grotesk comme police par dÃ©faut.

### Nouvelles mises en page

Les composants de mise en page disponibles dans le rÃ©pertoire Â« layouts Â» fournissent un moyen simple de personnaliser l'apparence du blog.[^2]

L'inconvÃ©nient de crÃ©er un modÃ¨le populaire est que vous commencez Ã  voir plusieurs sites similaires partout ğŸ˜†. Bien que les utilisateurs soient encouragÃ©s Ã  personnaliser les mises en page Ã  leur guise, le fait de disposer de plus d'options de mise en page facilement commutables favorise la diversitÃ© et peut peut-Ãªtre constituer un bon point de dÃ©part pour des personnalisations supplÃ©mentaires.

Dans la v2, j'ai ajoutÃ© une nouvelle mise en page de publication - `PostBanner`. Il comporte une grande image de banniÃ¨re et un conteneur de contenu centrÃ©. Consultez le billet de blog Â«Â [Photos du Canada](/blog/images-du-canada)Â Â» qui a Ã©tÃ© mis Ã  jour pour utiliser la nouvelle mise en page.

La prÃ©sentation par dÃ©faut de la liste des blogs a Ã©galement Ã©tÃ© mise Ã  jour pour inclure une barre latÃ©rale avec des balises de blog. La barre de recherche dans la prÃ©sentation prÃ©cÃ©dente a Ã©tÃ© remplacÃ©e par la nouvelle recherche par palette de commandes. Pour revenir Ã  l'ancienne mise en page, remplacez simplement les pages qui utilisent le composant `ListLayoutWithTags` par la `ListLayout` d'origine.

## Recommandations de migration

En raison des changements importants dans la structure des rÃ©pertoires, la configuration et les outils, je recommande de partir d'un nouveau modÃ¨le et de copier le contenu existant, puis de migrer progressivement les modifications vers le nouveau modÃ¨le.

Les modifications de style doivent Ãªtre relativement mineures et peuvent Ãªtre copiÃ©es de l'ancien Â« tailwind.config.js Â» vers le nouveau. En cas de copie, vous devrez peut-Ãªtre rajouter la classe Â« prose-dark Â» aux composants qui optent pour le style typographique tailwind. Modifiez l'importation de polices dans le composant de mise en page racine pour utiliser la police souhaitÃ©e.

Les modifications apportÃ©es au pipeline et au schÃ©ma de traitement MDX peuvent Ãªtre facilement transfÃ©rÃ©es vers la nouvelle configuration Contentlayer. S'il y a des modifications dans les champs frontmatter, vous pouvez modifier le type de document dans Â« contentlayer.config.ts Â» pour inclure les nouveaux champs. Des plugins personnalisÃ©s peuvent Ãªtre ajoutÃ©s aux propriÃ©tÃ©s `remarkPlugins` et `rehypePlugins` dans l'exportation `makeSource` de `contentlayer.config.ts`.

Les mises en page Markdown ne proviennent plus automatiquement du rÃ©pertoire Â« layouts Â». Au lieu de cela, ils doivent Ãªtre spÃ©cifiÃ©s dans l'objet `layouts` dÃ©fini dans `blog/[...slug]/page.tsx`.[^3]

Pour porter sur des composants ou des pages plus grandes, je recommande d'abord de le spÃ©cifier en tant que composant client en utilisant la directive `"use client"`. Une fois le rendu correct, vous pouvez diviser les composants interactifs (parties qui reposent sur des hooks Â«useÂ») en tant que composant client et conserver le code restant en tant que composant serveur. Consultez le [guide de migration] Next.js complet (https://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration#migrating-from-pages-to-app) pour plus de dÃ©tails .

## Conclusion

J'espÃ¨re que vous apprÃ©cierez les nouvelles fonctionnalitÃ©s et amÃ©liorations de la V2. Si vous avez des commentaires ou des suggestions, n'hÃ©sitez pas Ã  ouvrir un problÃ¨me ou Ã  me contacter sur [Twitter](https://twitter.com/timlrx).

## Support

Vous utilisez le modÃ¨le? Soutenez cet effort en attribuant une Ã©toile sur GitHub, en partageant votre propre blog et en criant sur Twitter ou en devenant un [sponsor] du projet (https://github.com/sponsors/timlrx).

## Licence

[MIT](https://github.com/timlrx/tailwind-nextjs-starter-blog/blob/main/LICENSE) Â© [Timothy Lin](https://www.timrlx.com)

[^1]: La version prÃ©cÃ©dente injecte Preact dans la version de production. Cependant, cela n'est plus possible car il ne prend pas en charge les composants React Server. Alors que la taille globale du bundle a augmentÃ© jusqu'Ã  environ 85 Ko, la plupart du contenu peut Ãªtre prÃ©-rendu cÃ´tÃ© serveur, ce qui se traduit par un premier rendu de contenu et un temps d'interactivitÃ© faibles. L'utilisation globale de React conduit Ã©galement Ã  un comportement plus cohÃ©rent avec les bibliothÃ¨ques et les composants externes.
[^2]: Ceci est diffÃ©rent des mises en page du rÃ©pertoire d'applications Next.js et est mieux considÃ©rÃ© comme des composants React rÃ©utilisables.
[^3]: Cela tire parti des composants serveur en simplifiant la spÃ©cification de la mise en page de votre choix dans le fichier markdown et la comparaison avec l'objet `layouts` qui est ensuite utilisÃ© pour restituer le composant de mise en page appropriÃ©.